---
layout: post
title:  "First-Class Statistical Missing Values Support in Julia 0.7"
author: Milan Bouchet-Valat
---

With the 0.7 release, Julia is going to enter the very select club of programming
languages with first-class support for statistical missing values.
Being essential for statistical analyses and data management, this feature is
common among specialized languages, such as
[SQL](https://en.wikipedia.org/wiki/Null_(SQL)) (with the `NULL` value),
[R](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling) (with [`NA`]),
[SAS](https://support.sas.com/documentation/cdl/en/lrcon/62955/HTML/default/viewer.htm#a001292604.htm)
(`.`, `' '`, etc.) or [Stata](https://www.stata.com/support/faqs/data-management/logical-expressions-and-missing-values/)
(`.`, etc.). It is however quite rare among general-purpose languages, with the notable
exception of [C#](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/using-nullable-types)
(`null`) and [VB.NET](https://docs.microsoft.com/en-us/dotnet/visual-basic/programming-guide/language-features/data-types/nullable-value-types) (`Nothing`).

Julia 0.7 introduced a new `missing` object used to represent statistical missing values.
Resulting from intense design discussions and of compiler improvements developed over several
years, it is the heir of the `NA` value implemented in the
[DataArrays](https://github.com/JuliaStats/DataArrays.jl) package, which
used to be the standard way of representing missing data in Julia.
`missing` is actually very similar to its predecessor, but it benefits from many
improvements in the Julia compiler and language which make it possible to drop the
`DataArray` type and use the standard `Array` type instead.

The expression "first class support" refers to three properties of the Julia
implementation of statistical missing values:

1. The `missing` object can be used in combination with any type, be it provided
   by Base or not.

2. Standard Julia code working with missing values is efficient, without special tricks.

3. Missing values are safe by default: they either propagate or throw an error.

This blog post develops these three strengths of the coming Julia 0.7 implementation of
missing values. This framework is used by
[version 0.11](https://discourse.julialang.org/t/dataframes-0-11-released/7296/)
of the DataFrames package, which already works on Julia 0.6 even if performance improvements
will only become available with Julia 0.7

## A generic representation

One of Julia's strengths is that user-defined types are as powerful and fast as built-in types.
To fully take advantage of this, missing values need to support not only standard types like
`Int`, `Float64` and `String`, but also any custom type. For this reason, Julia cannot use the
so-called *sentinel* approach like R and Pandas to represent missingness, that is special values
within a type's domain. For example, R represents missing values in integer and boolean
vectors using the smallest representable 32-bit integer (`-2,147,483,648`),
and missing values in floating point vectors using a specific `NaN` payload (`1954`,
which rumour says refers to Ross Ihaka's year of birth). Pandas only supports missing values
in floating point vectors, and conflates them with `NaN` values.

In order to provide a consistent representation of missing values which can be combined
with any type, Julia 0.7 will use [`missing`], an object with no fields which is the only
instance of the the `Missing` singleton type. This is a normal Julia type with a few
peculiarities which are detailed below. Values which can be either of type `T` or missing
can simply be declared as `Union{Missing,T}`. For example, a vector holding either integers
or missing values is of type `Array{Union{Missing,Int},1}`:

    julia> [1, missing]
    2-element Array{Union{Missing, Int64},1}:
    1
    missing

An interesting property of this approach is that `Array{Union{Missing,T}}` behaves just
like a normal `Array{T}` as soon as missing values have been replaced or skipped
(see below).

As can be seen in the example above, promotion rules are defined so that concatenating
values of type `T` and missing values gives an array with element type `Union{Missing,T}`
rather than `Any`:

    julia> promote_type(Int, Missing)
    Union{Missing, Int64}

These promotion rules are essential both for performance, as the next section shows.

## An efficient representation

Another of Julia's strengths is that one does not need to use tricks such as vectorized
calls to make code fast. In this spirit, working with missing values had to be
efficient without requiring special tricks. While the `Union{Missing,T}` approach
would have been very inefficient in previous Julia versions, the situation has
dramatically changed thanks to two improvements implemented in the compiler in
Julia 0.7.

The first improvement involves **optimizations for small `Union` types**.
When type inference detects that a variable can hold values of multiple types but
that these types are in limited number (as is the case for `Union{Missing,T}`),
the compiler will generate optimized code for each possible type in separate branches,
and run the appropriate one after checking the actual type of the value.
This produces code which is very close to that typically used with the sentinel
approach, in which one needs to check manually whether the processed value is equal
to the sentinel. This optimization is of course only available when the type is
inferred as a small `Union`: it is therefore essential to work with
`Array{Union{Missing,T}}` rather than `Array{Any}` objects, to provide the compiler
with the necessary type information.

The second one consists in using a **compact memory layout for arrays with `Union`s
of bits types**. The standard `Array` type now uses an optimized memory layout for
element types which are `Union` of bits types, i.e. immutable types which contain
no references (see `isbits`). This includes `Missing` and basic types such as
`Int`, `Float64`, `Complex{Float64}`, `Date`. When `T` is a bits type,
`Array{Union{Missing,T}}` objects are internally represented as a pair of arrays
of the same size: an `Array{T}` holding non-missing values and uninitialized memory
for missing values; and an `Array{UInt8}` storing a *type tag* indicating whether
each entry is `Missing` or `T`.

This layout consumes slightly more memory than the sentinel approach, as the
type tag part occupies one byte for each entry. But this overhead is reasonable:
for example, the memory usage of an `Array{Union{Missing,Float64}}` is only
12.5% higher than that of an `Array{Float64}`. Compared with the sentinel approach,
it has the advantage of being fully generic (as detailed in the previous section).
Actually, this mechanism can be used in other situations, for example with `Union{Nothing,Int}`
(which is the elementy type of the array returned by `indexin` in Julia 0.7).
It is also more correct, as the sentinel approach can fail in corner cases: for example,
in R, `NA + NaN` returns `NA` but `NaN + NA` returns `NaN` due to floating point
computation rules.

Arrays of non-bits types with missing values are also represented efficiently
compared with their counterparts without missing values. Indeed, such arrays
already consist of pointers to the actual objects which live in a different
memory area. Missing values can be represented as a special pointer just like
non-missing values. This is notably the case for `Array{Union{Missing,String}}`.

The efficient memory layout of `Array` in the presence of missing values makes it
unnecessary to use dedicated array types like
[`DataArray`](https://github.com/JuliaStats/DataArrays.jl). In fact, the layout
of the `DataArray` type is very similar to that of `Array{Union{Missing,T}}`
described above. The only difference is that it uses a `BitArray` rather than an
`Array{UInt8}` to indicate whether a value is missing, therefore taking 1 bit per
entry rather than 8 bits. Even if it consumes more memory, the `Array{UInt8}` mask
approach is faster (at least in the current state of `BitArray`), and it generalizes
to `Union`s of more than two types. However, we are aware that other implementations
such as [PostgreSQL](https://www.postgresql.org/docs/9.5/static/storage-page-layout.html)
or [Apache Arrow](https://arrow.apache.org/docs/memory_layout.html#null-bitmaps)
use bitmaps equivalent to `BitArray`.

## Safety and propagation by default

In addition to being generic and efficient, the new missing values support in
Julia 0.7 aims to provide safety, in the sense that missing values should never
be silently ignored nor replaced with non-missing values. Missing values are a
delicate issue in statistical work, and a frequent source of bugs or invalid results.
Ignoring missing values amounts to performing data imputation, which should never
happen silently without an explicit request.

Therefore, passing `missing` to a function will always return `missing` or throw
an error (except for a few special functions presented below). For convenience,
standard operators and mathematical functions systematically propagate missing
values:

    julia> 1 + missing
    missing

    julia> missing^2
    missing

    julia> cos(missing)
    missing

    julia> round(missing)
    missing

    julia> "a" * missing
    missing

This is also the case with reduction operations:

    julia> sum([1, missing, 2])
    missing

    julia> mean([1, missing, 2])
    missing

On the other hand, indexing into a `Vector` with missing values is an error.
Missing values are *not* silently skipped, which would be equivalent to assuming
their are `false`.

    julia> x = 1:3
    1:3

    julia> x[[true, missing, false]]
    ERROR: ArgumentError: unable to check bounds for indices of type Missing

    julia> x[[1, missing]]
    ERROR: ArgumentError: unable to check bounds for indices of type Missing

Convenience functions are provided to get rid of missing values explicitly.
First, the `skipmissing` function returns an iterator over the non-missing values
in the passed collection. It is particularly useful to ignore missing values when
computing reductions. Call `collect` to obtain a vector with all non-missing values.

    julia> sum(skipmissing([1, missing, 2]))
    3

    julia> mean(skipmissing([1, missing, 2]))
    1.5

    julia> collect(skipmissing([1, missing, 2]))
    2-element Array{Int64,1}:
    1
    2

Second, the `coalesce` function returns the first non-missing argument, which
as a special case allows replacing missing values with a particular value.
Combined with the "dot" broadcasting syntax, it allows replacing all missing
values in an array:

    julia> coalesce(missing, 0)
    0

    julia> coalesce(missing, missing, 0)
    0

    julia> coalesce.([1, missing, 2], 0)
    3-element Array{Int64,1}:
    1
    0
    2

    julia> coalesce.([1, missing, 2], [2, 3, missing])
    3-element Array{Int64,1}:
    1
    3
    2

A very restricted set of functions and operators follow different semantics than
those described above. They can be grouped into three classes:

- `ismissing` returns `true` if the input is `missing`, and `false` otherwise.

- `===`, `isequal` and `isless` always return a Boolean. `===` and `isequal` return
  `true` when comparing `missing` to `missing`, and `false` otherwise.
  `isless` also belongs to this class, and returns `true` when
  comparing any non-missing value to `missing`, and `false` otherwise: missing values
  are sorted last.

- `&`, `|` and `⊻`/`xor` implement [three-valued logic](https://en.wikipedia.org/wiki/Three-valued_logic),
  returning either a Boolean value or `missing` depending on whether the result is
  fully determined even without knowing the "real" value behind `missing`.

- `==`, `<`, `>`, `<=` and `>=` return `missing` if one of the operands is `missing`
  just like any other operators. When called on collections containing missing values,
  these operators are applied recursively and also follow three-valued logic: they
  return `missing` if the result would depend on the "real" value of a `missing` element.
  This also applies to `all`, `any` and `in`.

Short-circuiting operators `&&` and `||`, just like `if` conditions, throw an error
if they need to evaluate a missing value.

See the [manual](https://docs.julialang.org/en/latest/manual/missing/) for more details
and illustrations about these rules.

## Current limitations and future developments

As illustrated above, the new `missing` representation satisfies most requirements for a
technical and scientific language like Julia. However, it suffers from some limitations,
some temporary and some more fundamental.

Temporary limitations concern compiler optimizations which are not yet implemented.
First, code involving missing values is [not yet](https://github.com/JuliaLang/julia/issues/23338)
as efficient as it could be. Second, conversion from `Array{T}` to `Array{Union{Missing,T}}`
currently involves a copy. In theory it should be possible to use the same memory for bits
types, since only the type tag array differs. Third, the Julia compiler is
[currently unable](https://github.com/JuliaLang/julia/issues/23336)
to generate code using [SIMD](https://en.wikipedia.org/wiki/SIMD) instructions when `missing`
values are involved. This is not insurmountable since masked SIMD instructions allow applying
an operation only on some values. While the absence of SIMD reduces noticeably the performance
of simple operations, it appears that Julia already achieves the same speed as vectorized
operations in R (which are implemented in C). So there is room for improvement, but the current
situation is already reasonably efficient.

A more fundamental limitation is inherent to the choice of the `Union{Missing,T}`
representation. In this representation, a non-missing value does not carry any information
about whether it could have been missing, i.e. about whether it has been extracted from an
array or from a column of a data set which allows for missing values. In practice, this means
that, if `x` is an `Array{Union{Missing,T}}` but does not actually contain missing values,
`map(f, x)` will return an `Array{T}`. This is because `map` chooses its return type based
only on the actual contents of the output, to avoid depending on type inference (which can
vary depending on compiler improvements). This also means that when applying a function
to each element in an `Array{Union{T,Missing}}`, one cannot choose the result type based
on the type of the first element, which can be problematic e.g. to decide whether a table
column should allow for `NULL` entries in a SQL database. This issue has been discussed
[at length](https://discourse.julialang.org/t/missing-data-and-namedtuple-compatibility/8136/)
in several occasions, but it is not clear yet which mitigating approach is the best one.


**Author**: [Milan Bouchet-Valat](http://bouchet-valat.site.ined.fr), Research Scientist,
French National Institute for Demographic Studies (Ined), Paris.

**Acknowledgements**: This framework is the result of collective efforts over several
years. [John Myles White](http://johnmyleswhite.com) lead the reflexion around missing
values support in Julia until 2017. Jameson Nash implemented compiler optimizations,
and Jacob Quinn has implemented the efficient memory layout for arrays. Alex Arslan,
Jeff Bezanson, Stefan Karpinski, Jameson Nash and Jacob Quinn have been the most central
participants in long and complex design discussions which have involved many other
developers.